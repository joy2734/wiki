<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Redux - Wiki</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Redux";
    var mkdocs_page_input_path = "redux/redux.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Wiki</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../mkdocs/">Mkdocs</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../webDevInit/">DevInitConfig</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../material/materialui/">MaterialUI</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../material/theming/">MaterialUITheme</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../react/react/">React</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../js/javascript/">JavaScript</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../reactnative/reactnative/">ReactNative</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../socket/socketio/">SocketIO</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../electron/electronDocs/">Electron</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Wiki</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
    
    <li>Redux</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="redux">Redux</h1>
<h2 id="redux-thunk">redux-thunk</h2>
<ul>
<li>액션 객체가 아닌 함수를 디스패치 할 수 있다.</li>
</ul>
<p>예제</p>
<pre><code class="language-javascript">//api/posts.js

// 포스트 목록을 가져오는 비동기 함수
export const getPosts = async () =&gt; {
  await sleep(500); // 0.5초 쉬고
  return posts; // posts 배열
};

// ID로 포스트를 조회하는 비동기 함수
export const getPostById = async id =&gt; {
  await sleep(500); // 0.5초 쉬고
  return posts.find(post =&gt; post.id === id); // id 로 찾아서 반환
};

///////////////////////////////////////

//lib/asyncUtils.js

// Promise에 기반한 Thunk를 만들어주는 함수입니다.
export const createPromiseThunk = (type, promiseCreator) =&gt; {
  const [SUCCESS, ERROR] = [`${type}_SUCCESS`, `${type}_ERROR`];

  // 이 함수는 promiseCreator가 단 하나의 파라미터만 받는다는 전제하에 작성되었습니다.
  // 만약 여러 종류의 파라미터를 전달해야하는 상황에서는 객체 타입의 파라미터를 받아오도록 하면 됩니다.
  // 예: writeComment({ postId: 1, text: '댓글 내용' });
  return param =&gt; async dispatch =&gt; {
    // 요청 시작
    dispatch({ type, param });
    try {
      // 결과물의 이름을 payload 라는 이름으로 통일시킵니다.
      const payload = await promiseCreator(param);
      dispatch({ type: SUCCESS, payload }); // 성공
    } catch (e) {
      dispatch({ type: ERROR, payload: e, error: true }); // 실패
    }
  };
};


// 리듀서에서 사용 할 수 있는 여러 유틸 함수들입니다.
export const reducerUtils = {
  // 초기 상태. 초기 data 값은 기본적으로 null 이지만
  // 바꿀 수도 있습니다.
  initial: (initialData = null) =&gt; ({
    loading: false,
    data: initialData,
    error: null
  }),
  // 로딩중 상태. prevState의 경우엔 기본값은 null 이지만
  // 따로 값을 지정하면 null 로 바꾸지 않고 다른 값을 유지시킬 수 있습니다.
  loading: (prevState = null) =&gt; ({
    loading: true,
    data: prevState,
    error: null
  }),
  // 성공 상태
  success: payload =&gt; ({
    loading: false,
    data: payload,
    error: null
  }),
  // 실패 상태
  error: error =&gt; ({
    loading: false,
    data: null,
    error: error
  })
};

// 비동기 관련 액션들을 처리하는 리듀서를 만들어줍니다.
// type 은 액션의 타입, key 는 상태의 key (예: posts, post) 입니다.

export const handleAsyncActions = (type, key) =&gt; {
  const [SUCCESS, ERROR] = [`${type}_SUCCESS`, `${type}_ERROR`];
  return (state, action) =&gt; {
    switch (action.type) {
      case type:
      //만약 immer를사용한다면 더명확하게  state 값을 변경할 수있다.
        return produce(state, draft =&gt;{
          draft[key]:reducerUtils.loading()
        });
        // return {
        //   ...state,
        //   [key]: reducerUtils.loading()
        // };
      case SUCCESS:
        return {
          ...state,
          [key]: reducerUtils.success(action.payload)
        };
      case ERROR:
        return {
          ...state,
          [key]: reducerUtils.error(action.payload)
        };
      default:
        return state;
    }
  };
};


/////////POST리듀서////////////////////////
import * as postsAPI from '../api/posts'; // api/posts 안의 함수 모두 불러오기
import {
  createPromiseThunk,
  reducerUtils,
  handleAsyncActions
} from '../lib/asyncUtils';

/* 액션 타입 */

// 포스트 여러개 조회하기
const GET_POSTS = 'GET_POSTS'; // 요청 시작
const GET_POSTS_SUCCESS = 'GET_POSTS_SUCCESS'; // 요청 성공
const GET_POSTS_ERROR = 'GET_POSTS_ERROR'; // 요청 실패

// 포스트 하나 조회하기
const GET_POST = 'GET_POST';
const GET_POST_SUCCESS = 'GET_POST_SUCCESS';
const GET_POST_ERROR = 'GET_POST_ERROR';

// 아주 쉽게 thunk 함수를 만들 수 있게 되었습니다.
export const getPosts = createPromiseThunk(GET_POSTS, postsAPI.getPosts);
export const getPost = createPromiseThunk(GET_POST, postsAPI.getPostById);

// initialState 쪽도 반복되는 코드를 initial() 함수를 사용해서 리팩토링 했습니다.
const initialState = {
  posts: reducerUtils.initial(),
  post: reducerUtils.initial()
};

export default function posts(state = initialState, action) {
  switch (action.type) {
    case GET_POSTS:
    case GET_POSTS_SUCCESS:
    case GET_POSTS_ERROR:
      return handleAsyncActions(GET_POSTS, 'posts')(state, action);
    case GET_POST:
    case GET_POST_SUCCESS:
    case GET_POST_ERROR:
      return handleAsyncActions(GET_POST, 'post')(state, action);
    default:
      return state;
  }
}
</code></pre>
<h2 id="generator-redux-sage">Generator (redux-sage 선행)</h2>
<ul>
<li>function 앞에 * 붙이면 generator 함수로 선언.</li>
<li>해당함수 실행후 next() 호출시 1 &gt; 2 &gt; 3 &gt; 4 고정</li>
<li></li>
</ul>
<pre><code class="language-javascript">function* generatorFunction() {
    console.log('안녕하세요?');
    yield 1;
    console.log('제너레이터 함수');
    yield 2;
    console.log('function*');
    yield 3;
    return 4;
}
</code></pre>
<ul>
<li>제너레이터로 액션 모니터링하기</li>
</ul>
<pre><code class="language-javascript">function* watchGenerator() {
    console.log('모니터링 시작!');
    while(true) {
        const action = yield;
        if (action.type === 'HELLO') {
            console.log('안녕하세요?');
        }
        if (action.type === 'BYE') {
            console.log('안녕히가세요.');
        }
    }
}
const watch = watchGenerator();
watch.next({type: 'HELLO'}); //안녕하세요
</code></pre>
<h2 id="redux-saga">redux-saga</h2>
<ul>
<li><code>액션을 모니터링하고 있다가, 특정 액션이 발생하면 이에 따라 특정 작업을 하는 방식</code>으로 사용합니다.</li>
<li>비동기 작업을 할 때 기존 요청을 취소 처리 할 수 있습니다</li>
<li>특정 액션이 발생했을 때 이에 따라 다른 액션이 디스패치되게끔 하거나, 자바스크립트 코드를 실행 할 수 있습니다.</li>
<li>웹소켓을 사용하는 경우 Channel 이라는 기능을 사용하여 더욱 효율적으로 코드를 관리 할 수 있습니다 (참고)</li>
<li>
<p>API 요청이 실패했을 때 재요청하는 작업을 할 수 있습니다.</p>
</li>
<li>
<p>함수</p>
<ul>
<li>put</li>
<li>takeEvery - 특정 액션 타입에 대하여 디스패치되는 모든 액션들을 처리하는 것</li>
<li>takeLatest -특정 액션 타입에 대하여 디스패치된 가장 마지막 액션만을 처리하는 </li>
<li>call</li>
<li>delay
 함수</li>
<li>all 은 배열 안에 여러사가를 동시에 실행.</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">    import { delay, put, takeEvery, takeLatest } from 'redux-saga/effects';

    // 액션 타입
    const INCREASE = 'INCREASE';
    const DECREASE = 'DECREASE';
    const INCREASE_ASYNC = 'INCREASE_ASYNC';
    const DECREASE_ASYNC = 'DECREASE_ASYNC';

    // 액션 생성 함수
    export const increase = () =&gt; ({ type: INCREASE });
    export const decrease = () =&gt; ({ type: DECREASE });
    export const increaseAsync = () =&gt; ({ type: INCREASE_ASYNC });
    export const decreaseAsync = () =&gt; ({ type: DECREASE_ASYNC });

    function* increaseSaga() {
        yield delay(1000); // 1초를 기다립니다.
        yield put(increase()); // put은 특정 액션을 디스패치 해줍니다.
    }
    function* decreaseSaga() {
        yield delay(1000); // 1초를 기다립니다.
        yield put(decrease()); // put은 특정 액션을 디스패치 해줍니다.
    }

    export function* counterSaga() {
        yield takeEvery(INCREASE_ASYNC, increaseSaga); // 모든 INCREASE_ASYNC 액션을 처리
        yield takeLatest(DECREASE_ASYNC, decreaseSaga); // 가장 마지막으로 디스패치된 DECREASE_ASYNC 액션만을 처리
    }

    // 초깃값 (상태가 객체가 아니라 그냥 숫자여도 상관 없습니다.)
    const initialState = 0;

    export default function counter(state = initialState, action) {
        switch (action.type) {
            case INCREASE:
            return state + 1;
            case DECREASE:
            return state - 1;
            default:
            return state;
        }
    }

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
import { combineReducers } from 'redux';
import counter, { counterSaga } from './counter';
import posts from './posts';
import { all } from 'redux-saga/effects';

const rootReducer = combineReducers({ counter, posts });
export function* rootSaga() {
  yield all([counterSaga()]); // all 은 배열 안의 여러 사가를 동시에 실행시켜줍니다.
}

export default rootReducer;

    ///////////////////////////////////
    ///////////////////////////////////

import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import * as serviceWorker from './serviceWorker';
import { createStore, applyMiddleware } from 'redux';
import { Provider } from 'react-redux';
import rootReducer, { rootSaga } from './modules';
import logger from 'redux-logger';
import { composeWithDevTools } from 'redux-devtools-extension';
import ReduxThunk from 'redux-thunk';
import { Router } from 'react-router-dom';
import { createBrowserHistory } from 'history';
import createSagaMiddleware from 'redux-saga';

const customHistory = createBrowserHistory();
const sagaMiddleware = createSagaMiddleware(); // 사가 미들웨어를 만듭니다.

const store = createStore(
  rootReducer,
  // logger 를 사용하는 경우, logger가 가장 마지막에 와야합니다.
  composeWithDevTools(
    applyMiddleware(
      ReduxThunk.withExtraArgument({ history: customHistory }),
      sagaMiddleware, // 사가 미들웨어를 적용하고
      logger
    )
  )
); // 여러개의 미들웨어를 적용 할 수 있습니다.

sagaMiddleware.run(rootSaga); // 루트 사가를 실행해줍니다.
// 주의: 스토어 생성이 된 다음에 위 코드를 실행해야합니다.

ReactDOM.render(
  &lt;Router history={customHistory}&gt;
    &lt;Provider store={store}&gt;
      &lt;App /&gt;
    &lt;/Provider&gt;
  &lt;/Router&gt;,
  document.getElementById('root')
);

serviceWorker.unregister();   
</code></pre>
<ul>
<li>기존 react-thunk 을 react-saga로 변환코드
    https://react.vlpt.us/redux-middleware/11-redux-saga-with-promise.html</li>
</ul>
<h2 id="immer-produce">immer produce</h2>
<ul>
<li>produce 함수 첫번째인자 현재 state, 두번째인자 생산자함수(변경을 도와주는).</li>
<li>yarn add immer</li>
</ul>
<p>ex1)</p>
<pre><code class="language-javascript">import produce from 'immer';
const state = {
  number: 1,
  dontChangeMe: 2
};

const nextState = produce(state, draft =&gt; {
  draft.number += 1;
});

console.log(nextState);
// { number: 2, dontChangeMe: 2 }
</code></pre>
<p>ex2)</p>
<pre><code class="language-javascript">import React, { useReducer, useMemo } from 'react';
import UserList from './UserList';
import CreateUser from './CreateUser';
import produce from 'immer';

function countActiveUsers(users) {
  console.log('활성 사용자 수를 세는중...');
  return users.filter(user =&gt; user.active).length;
}

const initialState = {
  users: [
    {
      id: 1,
      username: 'velopert',
      email: 'public.velopert@gmail.com',
      active: true
    },
    {
      id: 2,
      username: 'tester',
      email: 'tester@example.com',
      active: false
    },
    {
      id: 3,
      username: 'liz',
      email: 'liz@example.com',
      active: false
    }
  ]
};

function reducer(state, action) {
  switch (action.type) {
    case 'CREATE_USER':
      return produce(state, draft =&gt; {
        draft.users.push(action.user);
      });
    case 'TOGGLE_USER':
      return produce(state, draft =&gt; {
        const user = draft.users.find(user =&gt; user.id === action.id);
        user.active = !user.active;
      });
    case 'REMOVE_USER':
      return produce(state, draft =&gt; {
        const index = draft.users.findIndex(user =&gt; user.id === action.id);
        draft.users.splice(index, 1);
      });
    default:
      return state;
  }
}

// UserDispatch 라는 이름으로 내보내줍니다.
export const UserDispatch = React.createContext(null);

function App() {
  const [state, dispatch] = useReducer(reducer, initialState);

  const { users } = state;

  const count = useMemo(() =&gt; countActiveUsers(users), [users]);
  return (
    &lt;UserDispatch.Provider value={dispatch}&gt;
      &lt;CreateUser /&gt;
      &lt;UserList users={users} /&gt;
      &lt;div&gt;활성사용자 수 : {count}&lt;/div&gt;
    &lt;/UserDispatch.Provider&gt;
  );
}

export default App;

</code></pre>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
